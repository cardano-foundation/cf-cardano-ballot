<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CardanoWeb3Filter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">voting-app</a> &gt; <a href="index.source.html" class="el_package">org.cardano.foundation.voting.service.auth.web3</a> &gt; <span class="el_source">CardanoWeb3Filter.java</span></div><h1>CardanoWeb3Filter.java</h1><pre class="source lang-java linenums">package org.cardano.foundation.voting.service.auth.web3;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import lombok.val;
import org.cardano.foundation.voting.client.ChainFollowerClient;
import org.cardano.foundation.voting.domain.ChainNetwork;
import org.cardano.foundation.voting.domain.web3.SignedCIP30;
import org.cardano.foundation.voting.domain.web3.WalletType;
import org.cardano.foundation.voting.service.auth.LoginSystemDetector;
import org.cardano.foundation.voting.service.expire.ExpirationService;
import org.cardano.foundation.voting.service.json.JsonService;
import org.cardano.foundation.voting.utils.Addresses;
import org.cardano.foundation.voting.utils.Enums;
import org.cardanofoundation.cip30.AddressFormat;
import org.cardanofoundation.cip30.CIP30Verifier;
import org.cardanofoundation.cip30.MessageFormat;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import org.zalando.problem.Problem;

import java.io.IOException;
import java.util.List;
import java.util.Optional;

import static com.bloxbean.cardano.client.crypto.Blake2bUtil.blake2bHash224;
import static com.bloxbean.cardano.client.util.HexUtil.decodeHexString;
import static com.bloxbean.cardano.client.util.HexUtil.encodeHexString;
import static org.cardano.foundation.voting.domain.Role.VOTER;
import static org.cardano.foundation.voting.domain.web3.WalletType.CARDANO;
import static org.cardano.foundation.voting.resource.Headers.*;
import static org.cardano.foundation.voting.service.auth.LoginSystem.CARDANO_CIP93;
import static org.cardano.foundation.voting.service.auth.web3.MoreFilters.sendBackProblem;
import static org.cardano.foundation.voting.utils.MoreNumber.isNumeric;
import static org.zalando.problem.Status.*;

@Component
<span class="fc" id="L45">@RequiredArgsConstructor</span>
<span class="fc" id="L46">@Slf4j</span>
public class CardanoWeb3Filter extends OncePerRequestFilter {

    private final JsonService jsonService;

    private final ExpirationService expirationService;

    private final ObjectMapper objectMapper;

    // TODO can we do this via local access?
    private final ChainFollowerClient chainFollowerClient;

    private final ChainNetwork chainNetworkStartedOn;

    private final LoginSystemDetector loginSystemDetector;

    @Override
    protected void doFilterInternal(HttpServletRequest req,
                                    HttpServletResponse res,
                                    FilterChain chain) throws ServletException, IOException {
<span class="fc" id="L66">        val maybeLoginSystem = loginSystemDetector.detect(req);</span>

<span class="fc bfc" id="L68" title="All 2 branches covered.">        if (maybeLoginSystem.isEmpty()) {</span>
<span class="fc" id="L69">            chain.doFilter(req, res);</span>
<span class="fc" id="L70">            return;</span>
        }

<span class="fc" id="L73">        val loginSystem = maybeLoginSystem.orElseThrow();</span>

<span class="fc bfc" id="L75" title="All 2 branches covered.">        if (loginSystem != CARDANO_CIP93) {</span>
<span class="fc" id="L76">            chain.doFilter(req, res);</span>
<span class="fc" id="L77">            return;</span>
        }

<span class="fc" id="L80">        val signatureM = Optional.ofNullable(req.getHeader(X_Ballot_Signature));</span>
<span class="fc" id="L81">        val publicKey = req.getHeader(X_Ballot_PublicKey);</span>
<span class="fc" id="L82">        val payloadM = Optional.ofNullable(req.getHeader(X_Ballot_Payload));</span>

<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (signatureM.isEmpty()) {</span>
<span class="fc" id="L85">            val problem = Problem.builder()</span>
<span class="fc" id="L86">                    .withTitle(&quot;NO_LOGIN_HTTP_HEADERS_SET&quot;)</span>
<span class="fc" id="L87">                    .withDetail(&quot;LOGIN http headers must be set.&quot;)</span>
<span class="fc" id="L88">                    .withStatus(BAD_REQUEST)</span>
<span class="fc" id="L89">                    .build();</span>

<span class="fc" id="L91">            sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L92">            return;</span>
        }
<span class="fc" id="L94">        val signature = signatureM.orElseThrow();</span>
<span class="fc" id="L95">        val signedWeb3Request = new SignedCIP30(signature, Optional.ofNullable(publicKey));</span>

<span class="fc" id="L97">        val cip30Verifier = new CIP30Verifier(signedWeb3Request.getSignature(), signedWeb3Request.getPublicKey());</span>
<span class="fc" id="L98">        val cipVerificationResult = cip30Verifier.verify();</span>

<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (!cipVerificationResult.isValid()) {</span>
<span class="fc" id="L101">            log.info(&quot;Unable to decode valid signed web3 request!&quot;);</span>

<span class="fc" id="L103">            val problem = Problem.builder()</span>
<span class="fc" id="L104">                    .withTitle(&quot;INVALID_CIP30_DATA_SIGNATURE&quot;)</span>
<span class="fc" id="L105">                    .withDetail(&quot;Invalid CIP93 cose signature!&quot;)</span>
<span class="fc" id="L106">                    .withStatus(UNAUTHORIZED)</span>
<span class="fc" id="L107">                    .build();</span>

<span class="fc" id="L109">            sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L110">            return;</span>
        }

<span class="fc" id="L113">        val maybeAddress = cipVerificationResult.getAddress(AddressFormat.TEXT);</span>

<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (maybeAddress.isEmpty()) {</span>
<span class="nc" id="L116">            val problem = Problem.builder()</span>
<span class="nc" id="L117">                    .withTitle(&quot;ADDRESS_NOT_FOUND&quot;)</span>
<span class="nc" id="L118">                    .withDetail(&quot;Bech32 address not found in the signed data.&quot;)</span>
<span class="nc" id="L119">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L120">                    .build();</span>

<span class="nc" id="L122">            sendBackProblem(objectMapper, res, problem);</span>
<span class="nc" id="L123">            return;</span>
        }

<span class="fc" id="L126">        val walletId = maybeAddress.orElseThrow();</span>

<span class="fc" id="L128">        var cipBody = cipVerificationResult.getMessage(MessageFormat.TEXT);</span>
<span class="fc bfc" id="L129" title="All 4 branches covered.">        if (cipVerificationResult.isHashed() &amp;&amp; payloadM.isEmpty()) {</span>
<span class="fc" id="L130">            val problem = Problem.builder()</span>
<span class="fc" id="L131">                    .withTitle(&quot;HASHED_CONTENT_NO_PAYLOAD&quot;)</span>
<span class="fc" id="L132">                    .withDetail(&quot;Payload was not sent along with the request and CIP-30 signature contains is hashed!&quot;)</span>
<span class="fc" id="L133">                    .withStatus(BAD_REQUEST)</span>
<span class="fc" id="L134">                    .build();</span>

<span class="fc" id="L136">            sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L137">            return;</span>
        }

<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (cipVerificationResult.isHashed()) {</span>
<span class="fc" id="L141">            val cipBodyHash = cipVerificationResult.getMessage(MessageFormat.HEX);</span>
<span class="fc" id="L142">            val payload = payloadM.orElseThrow();</span>

<span class="fc" id="L144">            val payloadHash = encodeHexString(blake2bHash224(decodeHexString(payload)));</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (!cipBodyHash.equals(payloadHash)) {</span>
<span class="fc" id="L147">                val problem = Problem.builder()</span>
<span class="fc" id="L148">                        .withTitle(&quot;CIP_30_HASH_MISMATCH&quot;)</span>
<span class="fc" id="L149">                        .withDetail(&quot;Signed hash does not match our precalculated hash!&quot;)</span>
<span class="fc" id="L150">                        .withStatus(BAD_REQUEST)</span>
<span class="fc" id="L151">                        .build();</span>

<span class="fc" id="L153">                sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L154">                return;</span>
            }

<span class="fc" id="L157">            cipBody = new String(decodeHexString(payload)); // flip cipBody to be payload for further processing</span>
        }

<span class="fc" id="L160">        val cip93EnvelopeE = jsonService.decodeGenericCIP93(cipBody);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (cip93EnvelopeE.isEmpty()) {</span>
<span class="fc" id="L162">            log.info(&quot;Invalid CIP-93 envelope!&quot;);</span>

<span class="fc" id="L164">            val problem = Problem.builder()</span>
<span class="fc" id="L165">                    .withTitle(&quot;INVALID_CIP93_ENVELOPE&quot;)</span>
<span class="fc" id="L166">                    .withDetail(&quot;CIP-93 envelope decoding failed.&quot;)</span>
<span class="fc" id="L167">                    .withStatus(BAD_REQUEST)</span>
<span class="fc" id="L168">                    .build();</span>

<span class="fc" id="L170">            sendBackProblem(objectMapper, res, problem);</span>

<span class="fc" id="L172">            return;</span>
        }

<span class="fc" id="L175">        val genericEnvelope = cip93EnvelopeE.get();</span>

<span class="fc" id="L177">        val maybeWeb3Action = genericEnvelope.getActionAsEnum();</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (maybeWeb3Action.isEmpty()) {</span>
<span class="nc" id="L179">            log.info(&quot;Unrecognised action, action:{}&quot;, genericEnvelope.getAction());</span>

<span class="nc" id="L181">            val problem = Problem.builder()</span>
<span class="nc" id="L182">                    .withTitle(&quot;ACTION_NOT_FOUND&quot;)</span>
<span class="nc" id="L183">                    .withDetail(&quot;Action not found!&quot;)</span>
<span class="nc" id="L184">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L185">                    .build();</span>

<span class="nc" id="L187">            sendBackProblem(objectMapper, res, problem);</span>
<span class="nc" id="L188">            return;</span>
        }

<span class="fc" id="L191">        val web3Action = maybeWeb3Action.orElseThrow();</span>

<span class="fc" id="L193">        val slotStr = genericEnvelope.getSlot();</span>

<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (!isNumeric(slotStr)) {</span>
<span class="fc" id="L196">            val problem = Problem.builder()</span>
<span class="fc" id="L197">                    .withTitle(&quot;INVALID_SLOT&quot;)</span>
<span class="fc" id="L198">                    .withDetail(&quot;CIP-93 envelope slot is not numeric!&quot;)</span>
<span class="fc" id="L199">                    .withStatus(BAD_REQUEST)</span>
<span class="fc" id="L200">                    .build();</span>

<span class="fc" id="L202">            sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L203">            return;</span>
        }

<span class="fc" id="L206">        val chainTipE = chainFollowerClient.getChainTip();</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (chainTipE.isEmpty()) {</span>
<span class="fc" id="L208">            val problem = Problem.builder()</span>
<span class="fc" id="L209">                    .withTitle(&quot;CHAIN_TIP_ERROR&quot;)</span>
<span class="fc" id="L210">                    .withDetail(&quot;Unable to get chain tip from chain-tip follower service, reason: &quot; + chainTipE.swap().get().getDetail())</span>
<span class="fc" id="L211">                    .withStatus(INTERNAL_SERVER_ERROR)</span>
<span class="fc" id="L212">                    .build();</span>

<span class="fc" id="L214">            sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L215">            return;</span>
        }
<span class="fc" id="L217">        val chainTip = chainTipE.get();</span>

<span class="fc" id="L219">        val slotE = genericEnvelope.getSlotAsLong();</span>
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">        if (slotE.isLeft()) {</span>
<span class="nc" id="L221">            val problem = slotE.getLeft();</span>

<span class="nc" id="L223">            sendBackProblem(objectMapper, res, problem);</span>
<span class="nc" id="L224">            return;</span>
        }
<span class="fc" id="L226">        val slot = slotE.get();</span>

<span class="fc" id="L228">        val slotExpired = expirationService.isSlotExpired(chainTip, slot);</span>

<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (slotExpired) {</span>
<span class="fc" id="L231">            val problem = Problem.builder()</span>
<span class="fc" id="L232">                    .withTitle(&quot;EXPIRED_SLOT&quot;)</span>
<span class="fc" id="L233">                    .withDetail(&quot;CIP-93 envelope slot expired!&quot;)</span>
<span class="fc" id="L234">                    .withStatus(BAD_REQUEST)</span>
<span class="fc" id="L235">                    .build();</span>

<span class="fc" id="L237">            sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L238">            return;</span>
        }

<span class="fc" id="L241">        val eventId = (String) genericEnvelope.getData().get(&quot;event&quot;);</span>
<span class="fc" id="L242">        val networkString = (String) genericEnvelope.getData().get(&quot;network&quot;);</span>
<span class="fc" id="L243">        val envelopeWalletId = (String) genericEnvelope.getData().get(&quot;walletId&quot;);</span>
<span class="fc" id="L244">        val envelopeWalletTypeM = Enums.getIfPresent(WalletType.class, (String) genericEnvelope.getData().get(&quot;walletType&quot;));</span>

<span class="fc bfc" id="L246" title="All 2 branches covered.">        if (envelopeWalletTypeM.isEmpty()) {</span>
<span class="fc" id="L247">            val problem = Problem.builder()</span>
<span class="fc" id="L248">                    .withTitle(&quot;MISSING_WALLET_TYPE&quot;)</span>
<span class="fc" id="L249">                    .withDetail(&quot;CIP-93 envelope walletType not found!&quot;)</span>
<span class="fc" id="L250">                    .withStatus(BAD_REQUEST)</span>
<span class="fc" id="L251">                    .build();</span>

<span class="fc" id="L253">            sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L254">            return;</span>
        }
<span class="fc" id="L256">        val envelopeWalletType = envelopeWalletTypeM.orElseThrow();</span>

<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (envelopeWalletType != CARDANO) {</span>
<span class="nc" id="L259">            val problem = Problem.builder()</span>
<span class="nc" id="L260">                    .withTitle(&quot;MUST_BE_CARDANO_WALLET&quot;)</span>
<span class="nc" id="L261">                    .withDetail(&quot;Only Cardano wallet type supported for CIP-93 envelopes!&quot;)</span>
<span class="nc" id="L262">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L263">                    .build();</span>

<span class="nc" id="L265">            sendBackProblem(objectMapper, res, problem);</span>
<span class="nc" id="L266">            return;</span>
        }

<span class="fc" id="L269">        val networkM = Enums.getIfPresent(ChainNetwork.class, networkString);</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (networkM.isEmpty()) {</span>
<span class="fc" id="L271">            val problem = Problem.builder()</span>
<span class="fc" id="L272">                    .withTitle(&quot;INVALID_NETWORK&quot;)</span>
<span class="fc" id="L273">                    .withDetail(&quot;Invalid chainNetwork, supported networks:&quot; + ChainNetwork.supportedNetworks())</span>
<span class="fc" id="L274">                    .withStatus(BAD_REQUEST)</span>
<span class="fc" id="L275">                    .build();</span>

<span class="fc" id="L277">            sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L278">            return;</span>
        }

<span class="fc" id="L281">        val chainNetwork = networkM.get();</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (chainNetwork != chainNetworkStartedOn) {</span>
<span class="fc" id="L283">            log.warn(&quot;Invalid chainNetwork, network:{}&quot;, networkString);</span>

<span class="fc" id="L285">            val problem = Problem.builder()</span>
<span class="fc" id="L286">                    .withTitle(&quot;NETWORK_MISMATCH&quot;)</span>
<span class="fc" id="L287">                    .withDetail(&quot;Invalid chainNetwork, backed configured with chainNetwork:&quot; + chainNetworkStartedOn + &quot;, however request is with chainNetwork:&quot; + chainNetwork)</span>
<span class="fc" id="L288">                    .withStatus(BAD_REQUEST)</span>
<span class="fc" id="L289">                    .build();</span>

<span class="fc" id="L291">            sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L292">            return;</span>
        }

<span class="fc" id="L295">        val walletIdE = Addresses.checkWalletId(chainNetwork, CARDANO, walletId);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (walletIdE.isEmpty()) {</span>
<span class="fc" id="L297">            val problem = walletIdE.getLeft();</span>

<span class="fc" id="L299">            sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L300">            return;</span>
        }

<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (!walletId.equals(envelopeWalletId)) {</span>
<span class="fc" id="L304">            val problem = Problem.builder()</span>
<span class="fc" id="L305">                    .withTitle(&quot;STAKE_ADDRESS_MISMATCH&quot;)</span>
<span class="fc" id="L306">                    .withDetail(&quot;Stake address mismatch, CIP-93 signed address:&quot; + walletId + &quot;, however request is with address:&quot; + envelopeWalletId)</span>
<span class="fc" id="L307">                    .withStatus(BAD_REQUEST)</span>
<span class="fc" id="L308">                    .build();</span>

<span class="fc" id="L310">            sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L311">            return;</span>
        }


<span class="fc" id="L315">        val eventDetailsE = chainFollowerClient.getEventDetails(eventId);</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (eventDetailsE.isEmpty()) {</span>
<span class="fc" id="L317">            val problem = Problem.builder()</span>
<span class="fc" id="L318">                    .withTitle(&quot;ERROR_GETTING_EVENT_DETAILS&quot;)</span>
<span class="fc" id="L319">                    .withDetail(&quot;Unable to get event details from chain-tip follower service, event:&quot; + eventId)</span>
<span class="fc" id="L320">                    .withStatus(INTERNAL_SERVER_ERROR)</span>
<span class="fc" id="L321">                    .build();</span>

<span class="fc" id="L323">            sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L324">            return;</span>
        }

<span class="fc" id="L327">        val eventDetailsM = eventDetailsE.get();</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">        if (eventDetailsM.isEmpty()) {</span>
<span class="fc" id="L329">            val problem = Problem.builder()</span>
<span class="fc" id="L330">                    .withTitle(&quot;UNRECOGNISED_EVENT&quot;)</span>
<span class="fc" id="L331">                    .withDetail(&quot;Event not found, id: &quot; + eventId)</span>
<span class="fc" id="L332">                    .withStatus(BAD_REQUEST)</span>
<span class="fc" id="L333">                    .build();</span>

<span class="fc" id="L335">            sendBackProblem(objectMapper, res, problem);</span>
<span class="fc" id="L336">            return;</span>
        }

<span class="fc" id="L339">        val eventDetails = eventDetailsM.orElseThrow();</span>

<span class="fc" id="L341">        val commonWeb3Details = Web3CommonDetails.builder()</span>
<span class="fc" id="L342">                .event(eventDetails)</span>
<span class="fc" id="L343">                .walletType(CARDANO)</span>
<span class="fc" id="L344">                .walletId(walletId)</span>
<span class="fc" id="L345">                .chainTip(chainTip)</span>
<span class="fc" id="L346">                .action(web3Action)</span>
<span class="fc" id="L347">                .network(chainNetwork)</span>
<span class="fc" id="L348">                .build();</span>

<span class="fc" id="L350">        val cardanoWeb3Details = CardanoWeb3Details.builder()</span>
<span class="fc" id="L351">                .web3CommonDetails(commonWeb3Details)</span>
<span class="fc" id="L352">                .envelope(genericEnvelope)</span>
<span class="fc" id="L353">                .signedCIP30(signedWeb3Request)</span>
<span class="fc" id="L354">                .payload(cipBody)</span>
<span class="fc" id="L355">                .cip30VerificationResult(cipVerificationResult)</span>
<span class="fc" id="L356">                .build();</span>

<span class="fc" id="L358">        val authentication = new Web3AuthenticationToken(cardanoWeb3Details, List.of(new SimpleGrantedAuthority(VOTER.name())));</span>

<span class="fc" id="L360">        SecurityContextHolder.getContext().setAuthentication(authentication);</span>

<span class="fc" id="L362">        chain.doFilter(req, res);</span>
<span class="fc" id="L363">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>