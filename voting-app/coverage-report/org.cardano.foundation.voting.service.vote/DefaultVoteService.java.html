<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultVoteService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">voting-app</a> &gt; <a href="index.source.html" class="el_package">org.cardano.foundation.voting.service.vote</a> &gt; <span class="el_source">DefaultVoteService.java</span></div><h1>DefaultVoteService.java</h1><pre class="source lang-java linenums">package org.cardano.foundation.voting.service.vote;

import io.micrometer.core.annotation.Timed;
import io.vavr.control.Either;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import lombok.val;
import org.cardano.foundation.voting.client.ChainFollowerClient;
import org.cardano.foundation.voting.client.UserVerificationClient;
import org.cardano.foundation.voting.domain.UserVotes;
import org.cardano.foundation.voting.domain.VoteReceipt;
import org.cardano.foundation.voting.domain.entity.Vote;
import org.cardano.foundation.voting.domain.entity.VoteMerkleProof;
import org.cardano.foundation.voting.domain.web3.*;
import org.cardano.foundation.voting.repository.VoteRepository;
import org.cardano.foundation.voting.service.auth.jwt.JwtAuthenticationToken;
import org.cardano.foundation.voting.service.auth.web3.CardanoWeb3Details;
import org.cardano.foundation.voting.service.auth.web3.KeriWeb3Details;
import org.cardano.foundation.voting.service.auth.web3.Web3AuthenticationToken;
import org.cardano.foundation.voting.service.auth.web3.Web3ConcreteDetails;
import org.cardano.foundation.voting.service.json.JsonService;
import org.cardano.foundation.voting.service.merkle_tree.MerkleProofSerdeService;
import org.cardano.foundation.voting.service.merkle_tree.VoteMerkleProofService;
import org.cardano.foundation.voting.utils.MoreUUID;
import org.cardanofoundation.merkle.ProofItem;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.zalando.problem.Problem;

import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;

import static com.bloxbean.cardano.client.util.HexUtil.encodeHexString;
import static org.cardano.foundation.voting.domain.VoteReceipt.Status.*;
import static org.cardano.foundation.voting.domain.VotingEventType.*;
import static org.cardano.foundation.voting.domain.web3.WalletType.KERI;
import static org.cardano.foundation.voting.domain.web3.Web3Action.*;
import static org.cardano.foundation.voting.utils.MoreNumber.isNumeric;
import static org.zalando.problem.Status.*;

@Service
<span class="fc" id="L44">@Slf4j</span>
@RequiredArgsConstructor
public class DefaultVoteService implements VoteService {

    private final VoteRepository voteRepository;
    private final VoteMerkleProofService voteMerkleProofService;
    private final MerkleProofSerdeService merkleProofSerdeService;
    private final ChainFollowerClient chainFollowerClient;
    private final UserVerificationClient userVerificationClient;
    private final JsonService jsonService;

    @Override
    @Transactional(readOnly = true)
    @Timed(value = &quot;service.vote.getVotes&quot;, histogram = true)
    public Either&lt;Problem, List&lt;UserVotes&gt;&gt; getVotes(JwtAuthenticationToken auth) {
<span class="fc" id="L59">        val jwtEventId = auth.eventDetails().id();</span>
<span class="fc" id="L60">        val jwtWalletType = auth.getWalletType();</span>
<span class="fc" id="L61">        val jwtWalletId = auth.getWalletId();</span>

<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if (auth.isActionNotAllowed(VOTES)) {</span>
<span class="nc" id="L64">            return Either.left(Problem.builder()</span>
<span class="nc" id="L65">                    .withTitle(&quot;ACTION_NOT_ALLOWED&quot;)</span>
<span class="nc" id="L66">                    .withDetail(&quot;Action VOTES not allowed for the role:&quot; + auth.role().name())</span>
<span class="nc" id="L67">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L68">                    .build());</span>
        }

<span class="fc" id="L71">        val userVotesList = voteRepository.getVotesByWalletId(jwtEventId, jwtWalletType, jwtWalletId)</span>
<span class="fc" id="L72">                .stream().map(p -&gt; {</span>
<span class="fc" id="L73">                    val cid = p.getCategoryId();</span>
<span class="fc" id="L74">                    val pid = p.getProposalId();</span>

<span class="fc" id="L76">                    return new UserVotes(cid, pid);</span>
<span class="fc" id="L77">                }).toList();</span>

<span class="fc" id="L79">        return Either.right(userVotesList);</span>
    }

    @Transactional(readOnly = true)
    @Timed(value = &quot;service.vote.isVoteChangingPossible&quot;, histogram = true)
    public Either&lt;Problem, Boolean&gt; isVoteChangingPossible(String voteId,
                                                           JwtAuthenticationToken auth) {
<span class="nc" id="L86">        val jwtEventId = auth.eventDetails().id();</span>

<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (auth.isActionNotAllowed(IS_VOTE_CHANGING_ALLOWED)) {</span>
<span class="nc" id="L89">            return Either.left(Problem.builder()</span>
<span class="nc" id="L90">                    .withTitle(&quot;ACTION_NOT_ALLOWED&quot;)</span>
<span class="nc" id="L91">                    .withDetail(&quot;Action IS_VOTE_CASTING_ALLOWED not allowed for the role:&quot; + auth.role().name())</span>
<span class="nc" id="L92">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L93">                    .build());</span>
        }
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (auth.eventDetails().isEventInactive()) {</span>
<span class="nc" id="L96">            return Either.right(false);</span>
        }

<span class="nc" id="L99">        val maybeExistingVote = voteRepository.findById(voteId);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (maybeExistingVote.isEmpty()) {</span>
<span class="nc" id="L101">            return Either.left(Problem.builder()</span>
<span class="nc" id="L102">                    .withTitle(&quot;VOTE_NOT_FOUND&quot;)</span>
<span class="nc" id="L103">                    .withDetail(&quot;Vote not found, voteId:&quot; + voteId)</span>
<span class="nc" id="L104">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L105">                    .build()</span>
            );
        }

<span class="nc" id="L109">        val maybeExistingProof = voteMerkleProofService.findLatestProof(jwtEventId, voteId);</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (maybeExistingProof.isPresent()) {</span>
<span class="nc" id="L111">            return Either.left(Problem.builder()</span>
<span class="nc" id="L112">                    .withTitle(&quot;VOTE_CANNOT_BE_CHANGED&quot;)</span>
<span class="nc" id="L113">                    .withDetail(&quot;Vote cannot be changed, voteId:&quot; + voteId)</span>
<span class="nc" id="L114">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L115">                    .build()</span>
            );
        }

<span class="nc" id="L119">        return Either.right(true);</span>
    }

    @Override
    @Transactional
    @Timed(value = &quot;service.vote.castVote&quot;, histogram = true)
    public Either&lt;Problem, Vote&gt; castVote(Web3AuthenticationToken web3AuthenticationToken) {
<span class="fc" id="L126">        val concreteDetails = web3AuthenticationToken.getDetails();</span>
<span class="fc" id="L127">        val details = concreteDetails.getWeb3CommonDetails();</span>

<span class="fc" id="L129">        val event = details.getEvent();</span>
<span class="fc" id="L130">        val eventId = event.id();</span>
<span class="fc" id="L131">        val walletId = details.getWalletId();</span>
<span class="fc" id="L132">        val walletType = details.getWalletType();</span>

<span class="fc" id="L134">        val castVoteE = unwrapCastCoteEnvelope(concreteDetails);</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if (castVoteE.isLeft()) {</span>
<span class="nc" id="L136">            return Either.left(castVoteE.getLeft());</span>
        }

<span class="fc" id="L139">        val castVote = castVoteE.get();</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        if (details.getAction() != CAST_VOTE) {</span>
<span class="nc" id="L141">            return Either.left(Problem.builder()</span>
<span class="nc" id="L142">                    .withTitle(&quot;INVALID_ACTION&quot;)</span>
<span class="nc" id="L143">                    .withDetail(&quot;Action is not CAST_VOTE, expected action:&quot; + CAST_VOTE.name())</span>
<span class="nc" id="L144">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L145">                    .build()</span>
            );
        }

<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (event.isEventInactive()) {</span>
<span class="nc" id="L150">            log.warn(&quot;Event is not active, id:{}&quot;, eventId);</span>

<span class="nc" id="L152">            return Either.left(Problem.builder()</span>
<span class="nc" id="L153">                    .withTitle(&quot;EVENT_IS_NOT_ACTIVE&quot;)</span>
<span class="nc" id="L154">                    .withDetail(&quot;Event is not active (not started or already finished), id:&quot; + eventId)</span>
<span class="nc" id="L155">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L156">                    .build());</span>
        }

<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        if (details.getChainTip().isNotSynced()) {</span>
<span class="nc" id="L160">            return Either.left(Problem.builder()</span>
<span class="nc" id="L161">                    .withTitle(&quot;CHAIN_FOLLOWER_NOT_SYNCED&quot;)</span>
<span class="nc" id="L162">                    .withDetail(&quot;Chain follower service not fully synced, please try again later!&quot;)</span>
<span class="nc" id="L163">                    .withStatus(INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L164">                    .build());</span>
        }

        // check which is specific for the USER_BASED event type
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (event.votingEventType() == USER_BASED) {</span>
<span class="nc" id="L169">            val userVerifiedE = userVerificationClient.isVerified(eventId, walletType, details.getWalletId());</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (userVerifiedE.isEmpty()) {</span>
<span class="nc" id="L171">                return Either.left(Problem.builder()</span>
<span class="nc" id="L172">                        .withTitle(&quot;ERROR_GETTING_USER_VERIFICATION_STATUS&quot;)</span>
<span class="nc" id="L173">                        .withDetail(&quot;Unable to get user verification status from user-verification service, reason: user verification service not available&quot;)</span>
<span class="nc" id="L174">                        .withStatus(INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L175">                        .build()</span>
                );
            }
<span class="nc" id="L178">            val userVerifiedResponse = userVerifiedE.get();</span>

<span class="nc bnc" id="L180" title="All 2 branches missed.">            if (userVerifiedResponse.isNotYetVerified()) {</span>
<span class="nc" id="L181">                log.warn(&quot;User is not verified, id:{}&quot;, eventId);</span>

<span class="nc" id="L183">                return Either.left(Problem.builder()</span>
<span class="nc" id="L184">                        .withTitle(&quot;USER_IS_NOT_VERIFIED&quot;)</span>
<span class="nc" id="L185">                        .withDetail(&quot;User is not verified, id:&quot; + eventId)</span>
<span class="nc" id="L186">                        .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L187">                        .build());</span>
            }
        }

<span class="fc" id="L191">        val categoryId = castVote.getCategory();</span>
<span class="fc" id="L192">        val categoryM = event.categoryDetailsById(categoryId);</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (categoryM.isEmpty()) {</span>
<span class="nc" id="L194">            log.warn(&quot;Unrecognised category, id:{}&quot;, categoryId);</span>

<span class="nc" id="L196">            return Either.left(Problem.builder()</span>
<span class="nc" id="L197">                    .withTitle(&quot;UNRECOGNISED_CATEGORY&quot;)</span>
<span class="nc" id="L198">                    .withDetail(&quot;Unrecognised category, id:&quot; + categoryId)</span>
<span class="nc" id="L199">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L200">                    .build());</span>
        }
<span class="fc" id="L202">        val category = categoryM.orElseThrow();</span>

<span class="fc" id="L204">        val proposalIdOrName = castVote.getProposal();</span>

        ChainFollowerClient.ProposalDetailsResponse proposal;
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (category.gdprProtection()) {</span>
<span class="nc" id="L208">            val maybeProposal = category.findProposalById(proposalIdOrName);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if (maybeProposal.isEmpty()) {</span>
<span class="nc" id="L210">                log.warn(&quot;Unrecognised proposal, proposalId:{}&quot;, proposalIdOrName);</span>

<span class="nc" id="L212">                return Either.left(Problem.builder()</span>
<span class="nc" id="L213">                        .withTitle(&quot;UNRECOGNISED_PROPOSAL&quot;)</span>
<span class="nc" id="L214">                        .withDetail(&quot;Unrecognised proposal, proposal:&quot; + proposalIdOrName)</span>
<span class="nc" id="L215">                        .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L216">                        .build());</span>
            }
<span class="nc" id="L218">            proposal = maybeProposal.orElseThrow();</span>
<span class="nc" id="L219">        } else {</span>
<span class="fc" id="L220">            val maybeProposal = category.findProposalByName(proposalIdOrName);</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">            if (maybeProposal.isEmpty()) {</span>
<span class="nc" id="L222">                log.warn(&quot;Unrecognised proposal, proposalId:{}&quot;, proposalIdOrName);</span>

<span class="nc" id="L224">                return Either.left(Problem.builder()</span>
<span class="nc" id="L225">                        .withTitle(&quot;UNRECOGNISED_PROPOSAL&quot;)</span>
<span class="nc" id="L226">                        .withDetail(&quot;Unrecognised proposal, proposal:&quot; + proposalIdOrName)</span>
<span class="nc" id="L227">                        .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L228">                        .build());</span>
            }
<span class="fc" id="L230">            proposal = maybeProposal.orElseThrow();</span>
        }

<span class="fc" id="L233">        String voteId = castVote.getId();</span>
<span class="pc bpc" id="L234" title="2 of 4 branches missed.">        if (voteId == null || !MoreUUID.isUUIDv4(voteId)) {</span>
<span class="nc" id="L235">            return Either.left(</span>
<span class="nc" id="L236">                    Problem.builder()</span>
<span class="nc" id="L237">                            .withTitle(&quot;INVALID_VOTE_ID&quot;)</span>
<span class="nc" id="L238">                            .withDetail(&quot;Invalid vote voteId: &quot; + voteId)</span>
<span class="nc" id="L239">                            .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L240">                            .build());</span>
        }

<span class="fc" id="L243">        val votedAtSlotStr = castVote.getVotedAt();</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (!isNumeric(votedAtSlotStr)) {</span>
<span class="nc" id="L245">            return Either.left(</span>
<span class="nc" id="L246">                    Problem.builder()</span>
<span class="nc" id="L247">                            .withTitle(&quot;INVALID_SLOT&quot;)</span>
<span class="nc" id="L248">                            .withDetail(&quot;Vote's votedAt slot is not numeric!&quot;)</span>
<span class="nc" id="L249">                            .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L250">                            .build()</span>
            );
        }

<span class="fc" id="L254">        val votedAtSlot = castVote.getVotedAtSlot();</span>

<span class="fc" id="L256">        val requestSlotE = concreteDetails.getRequestSlot();</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">        if (requestSlotE.isEmpty()) {</span>
<span class="nc" id="L258">            return Either.left(</span>
<span class="nc" id="L259">                    Problem.builder()</span>
<span class="nc" id="L260">                            .withTitle(&quot;INVALID_SLOT&quot;)</span>
<span class="nc" id="L261">                            .withDetail(&quot;Request slot is not numeric!&quot;)</span>
<span class="nc" id="L262">                            .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L263">                            .build()</span>
            );
        }

<span class="fc" id="L267">        val requestSlot = requestSlotE.get();</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">        if (votedAtSlot != requestSlot) {</span>
<span class="nc" id="L269">            log.warn(&quot;Slots mismatch, votedAt slot:{}, envelope's slot:{}&quot;, votedAtSlot, concreteDetails.getRequestSlot());</span>

<span class="nc" id="L271">            return Either.left(</span>
<span class="nc" id="L272">                    Problem.builder()</span>
<span class="nc" id="L273">                            .withTitle(&quot;SLOT_MISMATCH&quot;)</span>
<span class="nc" id="L274">                            .withDetail(&quot;Request envelope's slot and votedAt slot mismatch!&quot;)</span>
<span class="nc" id="L275">                            .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L276">                            .build()</span>
            );
        }

<span class="fc" id="L280">        val existingVoteM = voteRepository.findByEventIdAndCategoryIdAndWalletTypeAndWalletId(eventId, category.id(), walletType, walletId);</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if (existingVoteM.isPresent()) {</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">            if (!event.allowVoteChanging()) {</span>
<span class="nc" id="L283">                return Either.left(Problem.builder()</span>
<span class="nc" id="L284">                        .withTitle(&quot;VOTE_CANNOT_BE_CHANGED&quot;)</span>
<span class="nc" id="L285">                        .withDetail(&quot;Vote cannot be changed for the address: &quot; + walletId + &quot;, within category: &quot; + category.id() + &quot;, for event: &quot; + eventId)</span>
<span class="nc" id="L286">                        .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L287">                        .build()</span>
                );
            }
<span class="nc" id="L290">            val existingVote = existingVoteM.orElseThrow();</span>

<span class="nc" id="L292">            val maybeLatestProof = voteMerkleProofService.findLatestProof(eventId, existingVoteM.orElseThrow().getId());</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (maybeLatestProof.isPresent()) {</span>
<span class="nc" id="L294">                log.warn(&quot;Cannot change existing vote for the address: &quot; + walletId, &quot;, within category: &quot; + category.id() + &quot;, for event: &quot; + eventId);</span>

<span class="nc" id="L296">                return Either.left(</span>
<span class="nc" id="L297">                        Problem.builder()</span>
<span class="nc" id="L298">                                .withTitle(&quot;VOTE_CANNOT_BE_CHANGED&quot;)</span>
<span class="nc" id="L299">                                .withDetail(&quot;Vote cannot be changed for the address: &quot; + walletId + &quot;, within category: &quot; + category.id() + &quot;, for event: &quot; + eventId)</span>
<span class="nc" id="L300">                                .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L301">                                .build()</span>
                );
            }
<span class="nc" id="L304">            existingVote.setId(existingVote.getId());</span>
<span class="nc" id="L305">            existingVote.setProposalId(proposal.id());</span>
<span class="nc" id="L306">            existingVote.setVotedAtSlot(castVote.getVotedAtSlot());</span>
<span class="nc" id="L307">            existingVote.setWalletType(walletType);</span>
<span class="nc" id="L308">            existingVote.setSignature(concreteDetails.getSignature());</span>
<span class="nc" id="L309">            existingVote.setPayload(Optional.of(concreteDetails.getPayload()));</span>
<span class="nc" id="L310">            existingVote.setPublicKey(concreteDetails.getPublicKey());</span>

<span class="nc" id="L312">            return Either.right(voteRepository.saveAndFlush(existingVote));</span>
        }

<span class="fc" id="L315">        val vote = new Vote();</span>
<span class="fc" id="L316">        vote.setId(voteId);</span>
<span class="fc" id="L317">        vote.setEventId(event.id());</span>
<span class="fc" id="L318">        vote.setCategoryId(category.id());</span>
<span class="fc" id="L319">        vote.setProposalId(proposal.id());</span>
<span class="fc" id="L320">        vote.setWalletId(walletId);</span>
<span class="fc" id="L321">        vote.setWalletType(walletType);</span>
<span class="fc" id="L322">        vote.setVotedAtSlot(castVote.getVotedAtSlot());</span>
<span class="fc" id="L323">        vote.setSignature(concreteDetails.getSignature());</span>
<span class="fc" id="L324">        vote.setPayload(Optional.of(concreteDetails.getPayload()));</span>
<span class="fc" id="L325">        vote.setPublicKey(concreteDetails.getPublicKey());</span>
<span class="fc" id="L326">        vote.setIdNumericHash(UUID.fromString(voteId).hashCode() &amp; 0xFFFFFFF);</span>

        // KERI wallet type is not supported for account / balance voting events
<span class="pc bpc" id="L329" title="2 of 4 branches missed.">        if (event.votingEventType() != USER_BASED &amp;&amp; concreteDetails.getWeb3CommonDetails().getWalletType() == KERI) {</span>
<span class="nc" id="L330">            return Either.left(</span>
<span class="nc" id="L331">                    Problem.builder()</span>
<span class="nc" id="L332">                            .withTitle(&quot;KERI_NOT_SUPPORTED&quot;)</span>
<span class="nc" id="L333">                            .withDetail(&quot;Only Cardano wallet type supported for account / balance voting events is not supported.&quot;)</span>
<span class="nc" id="L334">                            .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L335">                            .build()</span>
            );
        }

<span class="pc bpc" id="L339" title="1 of 2 branches missed.">        if (List.of(STAKE_BASED, BALANCE_BASED).contains(event.votingEventType())) {</span>
<span class="fc" id="L340">            val accountE = chainFollowerClient.findAccount(eventId, walletType, walletId);</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">            if (accountE.isEmpty()) {</span>
<span class="nc" id="L342">                return Either.left(Problem.builder()</span>
<span class="nc" id="L343">                        .withTitle(&quot;ERROR_GETTING_ACCOUNT&quot;)</span>
<span class="nc" id="L344">                        .withDetail(&quot;Unable to get account from chain-tip follower service, address:&quot; + walletId)</span>
<span class="nc" id="L345">                        .withStatus(INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L346">                        .build()</span>
                );
            }
<span class="fc" id="L349">            val maybeAccount = accountE.get();</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            if (maybeAccount.isEmpty()) {</span>
<span class="nc" id="L351">                log.warn(&quot;State account not eligible to vote, e.g. not staked or power is less than equal 0 for the address: &quot; + walletId);</span>

<span class="nc" id="L353">                return Either.left(</span>
<span class="nc" id="L354">                        Problem.builder()</span>
<span class="nc" id="L355">                                .withTitle(&quot;NOT_ELIGIBLE&quot;)</span>
<span class="nc" id="L356">                                .withDetail(&quot;State account not eligible to vote, e.g. account not staked at snapshot epoch or voting power is less than equal 0 for the address:&quot; + walletId)</span>
<span class="nc" id="L357">                                .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L358">                                .build()</span>
                );
            }
<span class="fc" id="L361">            val account = maybeAccount.get();</span>

            // if we are eligible then we will have voting power
<span class="fc" id="L364">            val blockchainVotingPowerStr = account.votingPower();</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">            if (!isNumeric(blockchainVotingPowerStr)) {</span>
<span class="nc" id="L366">                return Either.left(</span>
<span class="nc" id="L367">                        Problem.builder()</span>
<span class="nc" id="L368">                                .withTitle(&quot;INVALID_VOTING_POWER&quot;)</span>
<span class="nc" id="L369">                                .withDetail(&quot;Invalid blockchain voting power for the address: &quot; + walletId)</span>
<span class="nc" id="L370">                                .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L371">                                .build()</span>
                );
            }
<span class="fc" id="L374">            val blockchainVotingPower = Long.parseLong(blockchainVotingPowerStr);</span>

<span class="pc bpc" id="L376" title="1 of 2 branches missed.">            if (!isNumeric(castVote.getVotingPower().orElseThrow())) {</span>
<span class="nc" id="L377">                return Either.left(</span>
<span class="nc" id="L378">                        Problem.builder()</span>
<span class="nc" id="L379">                                .withTitle(&quot;INVALID_VOTING_POWER&quot;)</span>
<span class="nc" id="L380">                                .withDetail(&quot;Vote's votingPower is not numeric for the address: &quot; + walletId)</span>
<span class="nc" id="L381">                                .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L382">                                .build()</span>
                );
            }
<span class="fc" id="L385">            val signedVotingPower = Long.parseLong(castVote.getVotingPower().orElseThrow());</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">            if (signedVotingPower != blockchainVotingPower) {</span>
<span class="nc" id="L387">                return Either.left(</span>
<span class="nc" id="L388">                        Problem.builder()</span>
<span class="nc" id="L389">                                .withTitle(&quot;VOTING_POWER_MISMATCH&quot;)</span>
<span class="nc" id="L390">                                .withDetail(&quot;Signed voting power is not equal to blockchain voting power for the stake address: &quot; + walletId)</span>
<span class="nc" id="L391">                                .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L392">                                .build()</span>
                );
            }

<span class="fc" id="L396">            vote.setVotingPower(Optional.of(blockchainVotingPower));</span>
        }

<span class="pc bpc" id="L399" title="1 of 2 branches missed.">        if (event.votingEventType() == USER_BASED) {</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">            if (vote.getVotingPower().isPresent()) {</span>
<span class="nc" id="L401">                return Either.left(</span>
<span class="nc" id="L402">                        Problem.builder()</span>
<span class="nc" id="L403">                                .withTitle(&quot;VOTING_POWER_NOT_SUPPORTED&quot;)</span>
<span class="nc" id="L404">                                .withDetail(&quot;Voting power makes no sense for USER_BASED events, please remove it from the cast vote's envelope.&quot;)</span>
<span class="nc" id="L405">                                .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L406">                                .build()</span>
                );
            }
        }

<span class="fc" id="L411">        return Either.right(voteRepository.saveAndFlush(vote));</span>
    }

    private Either&lt;Problem, ViewVoteReceiptEnvelope&gt; unwrapViewVoteReceiptEnvelope(Web3ConcreteDetails concreteDetails) {
<span class="fc" id="L415">        val signedJson = concreteDetails.getPayload();</span>

<span class="pc bpc" id="L417" title="2 of 3 branches missed.">        switch (concreteDetails) {</span>
<span class="fc" id="L418">            case CardanoWeb3Details cardanoWeb3Details -&gt; {</span>
<span class="fc" id="L419">                Either&lt;Problem, CIP93Envelope&lt;ViewVoteReceiptEnvelope&gt;&gt; viewVoteEnvelopeE = jsonService.decodeCIP93ViewVoteReceiptEnvelope(signedJson);</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">                if (viewVoteEnvelopeE.isLeft()) {</span>
<span class="nc" id="L421">                    return Either.left(</span>
<span class="nc" id="L422">                            Problem.builder()</span>
<span class="nc" id="L423">                                    .withTitle(&quot;INVALID_CIP93_DATA_SIGNATURE&quot;)</span>
<span class="nc" id="L424">                                    .withDetail(&quot;Error while decoding view vote receipt signature!&quot;)</span>
<span class="nc" id="L425">                                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L426">                                    .build()</span>
                    );
                }

<span class="fc" id="L430">                return Either.right(viewVoteEnvelopeE.get().getData());</span>
            }
<span class="nc" id="L432">            case KeriWeb3Details keriWeb3Details -&gt; {</span>
<span class="nc" id="L433">                Either&lt;Problem, KERIEnvelope&lt;ViewVoteReceiptEnvelope&gt;&gt; viewVoteEnvelopeE = jsonService.decodeKERIViewVoteReceiptEnvelope(signedJson);</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">                if (viewVoteEnvelopeE.isLeft()) {</span>
<span class="nc" id="L435">                    return Either.left(</span>
<span class="nc" id="L436">                            Problem.builder()</span>
<span class="nc" id="L437">                                    .withTitle(&quot;INVALID_KERI_DATA_SIGNATURE&quot;)</span>
<span class="nc" id="L438">                                    .withDetail(&quot;Error while decoding KERI view vote receipt signature!&quot;)</span>
<span class="nc" id="L439">                                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L440">                                    .build()</span>
                    );
                }

<span class="nc" id="L444">                return Either.right(viewVoteEnvelopeE.get().getData());</span>
            }
            default -&gt; {
<span class="nc" id="L447">                return Either.left(Problem.builder()</span>
<span class="nc" id="L448">                        .withTitle(&quot;UNSUPPORTED_WALLET_TYPE&quot;)</span>
<span class="nc" id="L449">                        .withDetail(&quot;Unsupported web3 details type:&quot; + concreteDetails.getClass().getName())</span>
<span class="nc" id="L450">                        .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L451">                        .build()</span>
                );
            }
        }
    }

    private Either&lt;Problem, VoteEnvelope&gt; unwrapCastCoteEnvelope(Web3ConcreteDetails concreteDetails) {
<span class="fc" id="L458">        val signedJson = concreteDetails.getPayload();</span>

<span class="pc bpc" id="L460" title="2 of 3 branches missed.">        switch (concreteDetails) {</span>
<span class="fc" id="L461">            case CardanoWeb3Details cardanoWeb3Details -&gt; {</span>
<span class="fc" id="L462">                val castVoteRequestBodyJsonE = jsonService.decodeCIP93VoteEnvelope(signedJson);</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">                if (castVoteRequestBodyJsonE.isLeft()) {</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                    if (castVoteRequestBodyJsonE.isLeft()) {</span>
<span class="nc" id="L465">                        return Either.left(</span>
<span class="nc" id="L466">                                Problem.builder()</span>
<span class="nc" id="L467">                                        .withTitle(&quot;INVALID_CIP93_DATA_SIGNATURE&quot;)</span>
<span class="nc" id="L468">                                        .withDetail(&quot;Error while decoding cast vote signature!&quot;)</span>
<span class="nc" id="L469">                                        .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L470">                                        .build()</span>
                        );
                    }
                }

<span class="fc" id="L475">                val cip93CastVoteEnvelope = castVoteRequestBodyJsonE.get();</span>

<span class="fc" id="L477">                return Either.right(cip93CastVoteEnvelope.getData());</span>
            }
<span class="nc" id="L479">            case KeriWeb3Details keriWeb3Details -&gt; {</span>
<span class="nc" id="L480">                val castVoteRequestBodyJsonE = jsonService.decodeKERIVoteEnvelope(signedJson);</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">                if (castVoteRequestBodyJsonE.isLeft()) {</span>
<span class="nc" id="L482">                    return Either.left(</span>
<span class="nc" id="L483">                            Problem.builder()</span>
<span class="nc" id="L484">                                    .withTitle(&quot;INVALID_KERI_DATA_SIGNATURE&quot;)</span>
<span class="nc" id="L485">                                    .withDetail(&quot;Error while decoding KERI cast vote signature!&quot;)</span>
<span class="nc" id="L486">                                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L487">                                    .build()</span>
                    );
                }
<span class="nc" id="L490">                val keriCastVoteEnvelope = castVoteRequestBodyJsonE.get();</span>

<span class="nc" id="L492">                return Either.right(keriCastVoteEnvelope.getData());</span>
            }
            default -&gt; {
<span class="nc" id="L495">                return Either.left(Problem.builder()</span>
<span class="nc" id="L496">                        .withTitle(&quot;UNSUPPORTED_WEB3_DETAILS&quot;)</span>
<span class="nc" id="L497">                        .withDetail(&quot;Unsupported web3 details type:&quot; + concreteDetails.getWeb3CommonDetails().getWalletType())</span>
<span class="nc" id="L498">                        .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L499">                        .build()</span>
                );
            }
        }
    }

    @Override
    @Transactional(readOnly = true)
    @Timed(value = &quot;service.vote.voteReceipts&quot;, histogram = true)
    public Either&lt;Problem, List&lt;VoteReceipt&gt;&gt; voteReceipts(JwtAuthenticationToken auth) {
<span class="fc" id="L509">        log.info(&quot;Fetching voter's receipts for the signed data...&quot;);</span>
<span class="fc" id="L510">        val jwtWalletId = auth.getWalletId();</span>
<span class="fc" id="L511">        val jwtWalletType = auth.getWalletType();</span>
<span class="fc" id="L512">        val eventDetails = auth.eventDetails();</span>

<span class="pc bpc" id="L514" title="1 of 2 branches missed.">        if (auth.isActionNotAllowed(VIEW_VOTE_RECEIPT)) {</span>
<span class="nc" id="L515">            return Either.left(Problem.builder()</span>
<span class="nc" id="L516">                    .withTitle(&quot;ACTION_NOT_ALLOWED&quot;)</span>
<span class="nc" id="L517">                    .withDetail(&quot;Action VIEW_VOTE_RECEIPT not allowed for the role:&quot; + auth.role().name())</span>
<span class="nc" id="L518">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L519">                    .build());</span>
        }

<span class="fc" id="L522">        val votes = voteRepository.findByEventIdAndWalletTypeAndWalletId(eventDetails.id(), jwtWalletType, jwtWalletId);</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">        if (votes.isEmpty()) {</span>
<span class="nc" id="L524">            return Either.left(Problem.builder()</span>
<span class="nc" id="L525">                    .withTitle(&quot;NO_VOTES_FOUND&quot;)</span>
<span class="nc" id="L526">                    .withDetail(&quot;No votes found for the wallet: &quot; + jwtWalletId)</span>
<span class="nc" id="L527">                    .withStatus(NOT_FOUND)</span>
<span class="nc" id="L528">                    .build());</span>
        }

<span class="fc" id="L531">        List&lt;VoteReceipt&gt; voteReceipts = votes.stream().map(vote -&gt; {</span>
<span class="fc" id="L532">            val categoryM = eventDetails.categoryDetailsById(vote.getCategoryId());</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">            if (categoryM.isEmpty()) {</span>
<span class="nc" id="L534">                log.warn(&quot;Unrecognised category, id:{}&quot;, vote.getCategoryId());</span>
<span class="nc" id="L535">                return null;</span>
            }
<span class="fc" id="L537">            val category = categoryM.orElseThrow();</span>

<span class="fc" id="L539">            val proposalM = category.findProposalById(vote.getProposalId());</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">            if (proposalM.isEmpty()) {</span>
<span class="nc" id="L541">                log.warn(&quot;Proposal not found for voteId:{}&quot;, vote.getId());</span>
<span class="nc" id="L542">                return null;</span>
            }
<span class="fc" id="L544">            val proposal = proposalM.orElseThrow();</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">            val proposalIdOrName = category.gdprProtection() ? proposal.id() : proposal.name();</span>

<span class="fc" id="L547">            val latestVoteMerkleProof = voteMerkleProofService.findLatestProof(eventDetails.id(), vote.getId());</span>

<span class="fc" id="L549">            return latestVoteMerkleProof.map(proof -&gt; {</span>
<span class="nc" id="L550">                log.info(&quot;Latest merkle proof found for voteId:{}&quot;, vote.getId());</span>

<span class="nc" id="L552">                val transactionDetailsE = chainFollowerClient.getTransactionDetails(proof.getL1TransactionHash());</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">                if (transactionDetailsE.isEmpty()) {</span>
<span class="nc" id="L554">                    log.warn(&quot;Unable to get transaction details from chain-tip follower service, transactionHash:{}&quot;, proof.getL1TransactionHash());</span>
<span class="nc" id="L555">                    return null;</span>
                }
<span class="nc" id="L557">                val transactionDetailsM = transactionDetailsE.get();</span>

<span class="nc" id="L559">                val isL1CommitmentOnChain = transactionDetailsM.map(ChainFollowerClient.TransactionDetailsResponse::finalityScore);</span>

<span class="nc" id="L561">                return VoteReceipt.builder()</span>
<span class="nc" id="L562">                        .id(vote.getId())</span>
<span class="nc" id="L563">                        .event(eventDetails.id())</span>
<span class="nc" id="L564">                        .category(category.id())</span>
<span class="nc" id="L565">                        .proposal(proposalIdOrName)</span>
<span class="nc" id="L566">                        .signature(vote.getSignature())</span>
<span class="nc" id="L567">                        .payload(vote.getPayload())</span>
<span class="nc" id="L568">                        .publicKey(vote.getPublicKey())</span>
<span class="nc" id="L569">                        .votedAtSlot(Long.valueOf(vote.getVotedAtSlot()).toString())</span>
<span class="nc" id="L570">                        .walletId(vote.getWalletId())</span>
<span class="nc" id="L571">                        .walletType(vote.getWalletType())</span>
<span class="nc" id="L572">                        .votingPower(vote.getVotingPower().map(String::valueOf))</span>
<span class="nc" id="L573">                        .status(readMerkleProofStatus(proof, isL1CommitmentOnChain))</span>
<span class="nc" id="L574">                        .finalityScore(isL1CommitmentOnChain)</span>
<span class="nc" id="L575">                        .merkleProof(convertMerkleProof(proof, transactionDetailsM))</span>
<span class="nc" id="L576">                        .build();</span>
<span class="fc" id="L577">            }).orElseGet(() -&gt; {</span>
<span class="fc" id="L578">                log.info(&quot;Merkle proof not found yet for voteId:{}&quot;, vote.getId());</span>

<span class="fc" id="L580">                return VoteReceipt.builder()</span>
<span class="fc" id="L581">                        .id(vote.getId())</span>
<span class="fc" id="L582">                        .event(eventDetails.id())</span>
<span class="fc" id="L583">                        .category(category.id())</span>
<span class="fc" id="L584">                        .proposal(proposalIdOrName)</span>
<span class="fc" id="L585">                        .signature(vote.getSignature())</span>
<span class="fc" id="L586">                        .payload(vote.getPayload())</span>
<span class="fc" id="L587">                        .publicKey(vote.getPublicKey())</span>
<span class="fc" id="L588">                        .votedAtSlot(Long.valueOf(vote.getVotedAtSlot()).toString())</span>
<span class="fc" id="L589">                        .walletId(vote.getWalletId())</span>
<span class="fc" id="L590">                        .walletType(vote.getWalletType())</span>
<span class="fc" id="L591">                        .votingPower(vote.getVotingPower().map(String::valueOf))</span>
<span class="fc" id="L592">                        .status(BASIC)</span>
<span class="fc" id="L593">                        .build();</span>
            });
<span class="fc" id="L595">        }).filter(Objects::nonNull).toList();</span>

<span class="fc" id="L597">        return Either.right(voteReceipts);</span>
    }


    @Override
    @Transactional(readOnly = true)
    @Timed(value = &quot;service.vote.voteReceipt&quot;, histogram = true)
    public Either&lt;Problem, VoteReceipt&gt; voteReceipt(Web3AuthenticationToken web3AuthenticationToken) {
<span class="fc" id="L605">        log.info(&quot;Fetching voter's receipt for the signed data...&quot;);</span>

<span class="fc" id="L607">        val concreteDetails = web3AuthenticationToken.getDetails();</span>
<span class="fc" id="L608">        val commonDetails = web3AuthenticationToken.getDetails().getWeb3CommonDetails();</span>

<span class="fc" id="L610">        val event = commonDetails.getEvent();</span>
<span class="fc" id="L611">        val walletType = commonDetails.getWalletType();</span>
<span class="fc" id="L612">        val walletId = commonDetails.getWalletId();</span>

<span class="fc" id="L614">        val viewVoteReceiptEnvelopeE = unwrapViewVoteReceiptEnvelope(concreteDetails);</span>
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">        if (viewVoteReceiptEnvelopeE.isLeft()) {</span>
<span class="nc" id="L616">            return Either.left(viewVoteReceiptEnvelopeE.getLeft());</span>
        }

<span class="fc" id="L619">        val viewVoteReceiptEnvelope = viewVoteReceiptEnvelopeE.get();</span>

<span class="pc bpc" id="L621" title="1 of 2 branches missed.">        if (commonDetails.getAction() != VIEW_VOTE_RECEIPT) {</span>
<span class="nc" id="L622">            return Either.left(Problem.builder()</span>
<span class="nc" id="L623">                    .withTitle(&quot;INVALID_ACTION&quot;)</span>
<span class="nc" id="L624">                    .withDetail(&quot;Action is not VIEW_VOTE_RECEIPT, action:&quot; + commonDetails.getAction())</span>
<span class="nc" id="L625">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L626">                    .build()</span>
            );
        }

<span class="fc" id="L630">        val categoryId = viewVoteReceiptEnvelope.getCategory();</span>

<span class="fc" id="L632">        return actualVoteReceipt(event, categoryId, walletType, walletId);</span>
    }

    @Override
    @Transactional(readOnly = true)
    public Either&lt;Problem, VoteReceipt&gt; voteReceipt(String categoryId,
                                                    JwtAuthenticationToken auth) {
<span class="fc" id="L639">        val jwtWalletId = auth.getWalletId();</span>
<span class="fc" id="L640">        val jwtWalletType = auth.getWalletType();</span>
<span class="fc" id="L641">        val eventDetails = auth.eventDetails();</span>

<span class="pc bpc" id="L643" title="1 of 2 branches missed.">        if (auth.isActionNotAllowed(VIEW_VOTE_RECEIPT)) {</span>
<span class="nc" id="L644">            return Either.left(Problem.builder()</span>
<span class="nc" id="L645">                    .withTitle(&quot;ACTION_NOT_ALLOWED&quot;)</span>
<span class="nc" id="L646">                    .withDetail(&quot;Action VIEW_VOTE_RECEIPT not allowed for the role:&quot; + auth.role().name())</span>
<span class="nc" id="L647">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L648">                    .build());</span>
        }

<span class="fc" id="L651">        return actualVoteReceipt(eventDetails, categoryId, jwtWalletType, jwtWalletId);</span>
    }

    private Either&lt;Problem, VoteReceipt&gt; actualVoteReceipt(ChainFollowerClient.EventDetailsResponse event,
                                                           String categoryId,
                                                           WalletType walletType,
                                                           String walletId) {
<span class="fc" id="L658">        val categoryM = event.categoryDetailsById(categoryId);</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">        if (categoryM.isEmpty()) {</span>
<span class="nc" id="L660">            log.warn(&quot;Unrecognised category, id:{}&quot;, categoryId);</span>

<span class="nc" id="L662">            return Either.left(Problem.builder()</span>
<span class="nc" id="L663">                    .withTitle(&quot;UNRECOGNISED_CATEGORY&quot;)</span>
<span class="nc" id="L664">                    .withDetail(&quot;Unrecognised category, id:&quot; + categoryId)</span>
<span class="nc" id="L665">                    .withStatus(BAD_REQUEST)</span>
<span class="nc" id="L666">                    .build());</span>
        }
<span class="fc" id="L668">        val category = categoryM.orElseThrow();</span>

<span class="fc" id="L670">        val voteM = voteRepository.findByEventIdAndCategoryIdAndWalletTypeAndWalletId(event.id(), category.id(), walletType, walletId);</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        if (voteM.isEmpty()) {</span>
<span class="nc" id="L672">            return Either.left(</span>
<span class="nc" id="L673">                    Problem.builder()</span>
<span class="nc" id="L674">                            .withTitle(&quot;VOTE_NOT_FOUND&quot;)</span>
<span class="nc" id="L675">                            .withDetail(&quot;Not voted yet for stakeKey:&quot; + walletId)</span>
<span class="nc" id="L676">                            .withStatus(NOT_FOUND)</span>
<span class="nc" id="L677">                            .build()</span>
            );
        }
<span class="fc" id="L680">        val vote = voteM.orElseThrow();</span>

<span class="fc" id="L682">        val proposalM = category.findProposalById(vote.getProposalId());</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">        if (proposalM.isEmpty()) {</span>
<span class="nc" id="L684">            return Either.left(</span>
<span class="nc" id="L685">                    Problem.builder()</span>
<span class="nc" id="L686">                            .withTitle(&quot;PROPOSAL_NOT_FOUND&quot;)</span>
<span class="nc" id="L687">                            .withDetail(&quot;Proposal not found for voteId:&quot; + vote.getId())</span>
<span class="nc" id="L688">                            .withStatus(NOT_FOUND)</span>
<span class="nc" id="L689">                            .build()</span>
            );
        }
<span class="fc" id="L692">        val proposal = proposalM.orElseThrow();</span>
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">        val proposalIdOrName = category.gdprProtection() ? proposal.id() : proposal.name();</span>

<span class="fc" id="L695">        val latestVoteMerkleProof = voteMerkleProofService.findLatestProof(event.id(), vote.getId());</span>

<span class="fc" id="L697">        return latestVoteMerkleProof.map(proof -&gt; {</span>
<span class="nc" id="L698">            log.info(&quot;Latest merkle proof found for voteId:{}&quot;, vote.getId());</span>

<span class="nc" id="L700">            val transactionDetailsE = chainFollowerClient.getTransactionDetails(proof.getL1TransactionHash());</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">            if (transactionDetailsE.isEmpty()) {</span>
<span class="nc" id="L702">                return Either.&lt;Problem, VoteReceipt&gt;left(Problem.builder()</span>
<span class="nc" id="L703">                        .withTitle(&quot;ERROR_GETTING_TRANSACTION_DETAILS&quot;)</span>
<span class="nc" id="L704">                        .withDetail(&quot;Unable to get transaction details from chain-tip follower service, transactionHash:&quot; + proof.getL1TransactionHash())</span>
<span class="nc" id="L705">                        .withStatus(INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L706">                        .build());</span>
            }
<span class="nc" id="L708">            val transactionDetailsM = transactionDetailsE.get();</span>

<span class="nc" id="L710">            val isL1CommitmentOnChain = transactionDetailsM.map(ChainFollowerClient.TransactionDetailsResponse::finalityScore);</span>

<span class="nc" id="L712">            return Either.&lt;Problem, VoteReceipt&gt;right(VoteReceipt.builder()</span>
<span class="nc" id="L713">                    .id(vote.getId())</span>
<span class="nc" id="L714">                    .event(event.id())</span>
<span class="nc" id="L715">                    .category(category.id())</span>
<span class="nc" id="L716">                    .proposal(proposalIdOrName)</span>
<span class="nc" id="L717">                    .signature(vote.getSignature())</span>
<span class="nc" id="L718">                    .payload(vote.getPayload())</span>
<span class="nc" id="L719">                    .publicKey(vote.getPublicKey())</span>
<span class="nc" id="L720">                    .votedAtSlot(Long.valueOf(vote.getVotedAtSlot()).toString())</span>
<span class="nc" id="L721">                    .walletId(vote.getWalletId())</span>
<span class="nc" id="L722">                    .walletType(vote.getWalletType())</span>
<span class="nc" id="L723">                    .votingPower(vote.getVotingPower().map(String::valueOf))</span>
<span class="nc" id="L724">                    .status(readMerkleProofStatus(proof, isL1CommitmentOnChain))</span>
<span class="nc" id="L725">                    .finalityScore(isL1CommitmentOnChain)</span>
<span class="nc" id="L726">                    .merkleProof(convertMerkleProof(proof, transactionDetailsM))</span>
<span class="nc" id="L727">                    .build());</span>

<span class="fc" id="L729">        }).orElseGet(() -&gt; {</span>
<span class="fc" id="L730">            log.info(&quot;Merkle proof not found yet for voteId:{}&quot;, vote.getId());</span>

<span class="fc" id="L732">            return Either.right(VoteReceipt.builder()</span>
<span class="fc" id="L733">                    .id(vote.getId())</span>
<span class="fc" id="L734">                    .event(event.id())</span>
<span class="fc" id="L735">                    .category(category.id())</span>
<span class="fc" id="L736">                    .proposal(proposalIdOrName)</span>
<span class="fc" id="L737">                    .signature(vote.getSignature())</span>
<span class="fc" id="L738">                    .payload(vote.getPayload())</span>
<span class="fc" id="L739">                    .publicKey(vote.getPublicKey())</span>
<span class="fc" id="L740">                    .votedAtSlot(Long.valueOf(vote.getVotedAtSlot()).toString())</span>
<span class="fc" id="L741">                    .walletId(vote.getWalletId())</span>
<span class="fc" id="L742">                    .walletType(vote.getWalletType())</span>
<span class="fc" id="L743">                    .votingPower(vote.getVotingPower().map(String::valueOf))</span>
<span class="fc" id="L744">                    .status(BASIC)</span>
<span class="fc" id="L745">                    .build()</span>
            );
        });
    }

    private static VoteReceipt.Status readMerkleProofStatus(VoteMerkleProof merkleProof,
                                                            Optional&lt;ChainFollowerClient.FinalityScore&gt; isL1CommitmentOnChain) {
<span class="nc bnc" id="L752" title="All 2 branches missed.">        if (merkleProof.isInvalidated()) {</span>
<span class="nc" id="L753">            return ROLLBACK;</span>
        }

<span class="nc bnc" id="L756" title="All 2 branches missed.">        return isL1CommitmentOnChain.isEmpty() ? PARTIAL : FULL;</span>
    }

    private VoteReceipt.MerkleProof convertMerkleProof(VoteMerkleProof proof,
                                                       Optional&lt;ChainFollowerClient.TransactionDetailsResponse&gt; transactionDetails) {
<span class="nc" id="L761">        return VoteReceipt.MerkleProof.builder()</span>
<span class="nc" id="L762">                .blockHash(transactionDetails.map(ChainFollowerClient.TransactionDetailsResponse::blockHash))</span>
<span class="nc" id="L763">                .absoluteSlot(transactionDetails.map(ChainFollowerClient.TransactionDetailsResponse::absoluteSlot))</span>
<span class="nc" id="L764">                .rootHash(proof.getRootHash())</span>
<span class="nc" id="L765">                .transactionHash(proof.getL1TransactionHash())</span>
<span class="nc" id="L766">                .steps(convertSteps(proof))</span>
<span class="nc" id="L767">                .build();</span>

    }

    private List&lt;VoteReceipt.MerkleProofItem&gt; convertSteps(VoteMerkleProof proof) {
<span class="nc" id="L772">        return merkleProofSerdeService.deserialise(proof.getProofItemsJson()).stream().map(item -&gt; {</span>

<span class="nc bnc" id="L774" title="All 2 branches missed.">            if (item instanceof ProofItem.Left pl) {</span>
<span class="nc" id="L775">                return VoteReceipt.MerkleProofItem.builder()</span>
<span class="nc" id="L776">                        .type(VoteReceipt.MerkleProofType.L)</span>
<span class="nc" id="L777">                        .hash(encodeHexString(pl.hash()))</span>
<span class="nc" id="L778">                        .build();</span>
            }

<span class="nc bnc" id="L781" title="All 2 branches missed.">            if (item instanceof ProofItem.Right pr) {</span>
<span class="nc" id="L782">                return VoteReceipt.MerkleProofItem.builder()</span>
<span class="nc" id="L783">                        .type(VoteReceipt.MerkleProofType.R)</span>
<span class="nc" id="L784">                        .hash(encodeHexString(pr.hash()))</span>
<span class="nc" id="L785">                        .build();</span>
            }

<span class="nc" id="L788">            throw new RuntimeException(&quot;Unknown proof item type:&quot; + item.getClass().getName());</span>
<span class="nc" id="L789">        }).toList();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>